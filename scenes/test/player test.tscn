[gd_scene load_steps=9 format=3 uid="uid://bl2mw4ncd16nw"]

[ext_resource type="PackedScene" uid="uid://d012q0hkarsoy" path="res://objects/player.tscn" id="1_kisq8"]
[ext_resource type="PackedScene" uid="uid://c88c4l3na103o" path="res://objects/enemy.tscn" id="2_r4juh"]

[sub_resource type="Shader" id="Shader_r4juh"]
resource_local_to_scene = true
code = "shader_type canvas_item;

const int MODE_TEXTURE_ONLY         = 0;
const int MODE_OUTLINE_ONLY         = 1;
const int MODE_OUTLINE_WITH_TEXTURE = 2;
const int MODE_STRIPE_ONLY          = 3;
const int MODE_STRIPE_WITH_TEXTURE  = 4;

uniform int draw_mode : hint_range(0, 4, 1) = 0;

uniform vec4 outline_color : source_color = vec4(1.0, 1.0, 1.0, 1.0);
uniform int outline_thickness : hint_range(1, 8, 1) = 1;

uniform float rotation_speed : hint_range(-4.0, 4.0) = 0.3;
uniform float stripes : hint_range(1.0, 32.0, 1.0) = 16.0;
uniform float stripe_width : hint_range(0.0, 1.0) = 0.5;

const float ALPHA_THRES = 0.01;

void fragment() {
    vec4 base = texture(TEXTURE, UV);
    vec2 px = TEXTURE_PIXEL_SIZE;

    /* ---- outline 판정 ---- */
    bool empty = base.a <= ALPHA_THRES;
    bool within = false;

    // 컴파일 안전용 고정 루프 (최대 8)
    for (int dy = -8; dy <= 8; dy++) {
        for (int dx = -8; dx <= 8; dx++) {
            if (abs(dx) > outline_thickness || abs(dy) > outline_thickness) {
                continue;
            }
            if (dx == 0 && dy == 0) {
                continue;
            }

            float a = texture(TEXTURE, UV + vec2(float(dx), float(dy)) * px).a;
            if (a > ALPHA_THRES) {
                within = true;
            }
        }
    }

    bool outline = empty && within;

    /* ---- stripe 계산 (outline 영역용 마스크) ---- */
    float fill = 1.0;
    if (draw_mode == MODE_STRIPE_ONLY || draw_mode == MODE_STRIPE_WITH_TEXTURE) {
        float rotation = TIME * rotation_speed;

        // 텍스처 픽셀 기준 좌표 (중심 기준)
        vec2 p = vec2(
            floor((UV.x - 0.5) / px.x),
            floor((UV.y - 0.5) / px.y)
        );

        float angle = atan(
            p.x * cos(rotation) + p.y * sin(rotation),
            p.y * cos(rotation) - p.x * sin(rotation)
        );

        float t = mod((angle - PI) / -TAU, 1.0 / stripes);
        fill = t < stripe_width / stripes ? 1.0 : 0.0;
    }


	vec4 res_col = vec4(0.0);

	if (draw_mode == MODE_TEXTURE_ONLY) {
	    res_col = base;
	}
	else if (draw_mode == MODE_OUTLINE_ONLY) {
	    res_col = outline ? outline_color : vec4(0.0);
	}
	else if (draw_mode == MODE_OUTLINE_WITH_TEXTURE) {
	    res_col = outline ? outline_color : base;
	}
	else if (draw_mode == MODE_STRIPE_ONLY) {
	    res_col = (outline && fill > 0.0) ? outline_color : vec4(0.0);
	}
	else if (draw_mode == MODE_STRIPE_WITH_TEXTURE) {
	    res_col = (outline && fill > 0.0) ? outline_color : base;
	}

	COLOR = res_col;

}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_ip0k5"]
resource_local_to_scene = true
shader = SubResource("Shader_r4juh")
shader_parameter/draw_mode = 2
shader_parameter/outline_color = Color(1, 1, 1, 1)
shader_parameter/outline_thickness = 2
shader_parameter/rotation_speed = 0.3
shader_parameter/stripes = 16.0
shader_parameter/stripe_width = 0.5

[sub_resource type="ShaderMaterial" id="ShaderMaterial_vaaja"]
resource_local_to_scene = true
shader = SubResource("Shader_r4juh")
shader_parameter/draw_mode = 2
shader_parameter/outline_color = Color(0, 0, 0, 1)
shader_parameter/outline_thickness = 2
shader_parameter/rotation_speed = 0.3
shader_parameter/stripes = 16.0
shader_parameter/stripe_width = 0.5

[sub_resource type="WorldBoundaryShape2D" id="WorldBoundaryShape2D_s0ptb"]

[sub_resource type="Shader" id="Shader_s0ptb"]
resource_local_to_scene = true
code = "shader_type canvas_item;

const int MODE_TEXTURE_ONLY         = 0;
const int MODE_OUTLINE_ONLY         = 1;
const int MODE_OUTLINE_WITH_TEXTURE = 2;
const int MODE_STRIPE_ONLY          = 3;
const int MODE_STRIPE_WITH_TEXTURE  = 4;

uniform int draw_mode : hint_range(0, 4, 1) = 0;

uniform vec4 outline_color : source_color = vec4(1.0, 1.0, 1.0, 1.0);
uniform int outline_thickness : hint_range(1, 8, 1) = 1;

uniform float rotation_speed : hint_range(-4.0, 4.0) = 0.3;
uniform float stripes : hint_range(1.0, 32.0, 1.0) = 16.0;
uniform float stripe_width : hint_range(0.0, 1.0) = 0.5;

const float ALPHA_THRES = 0.01;

void fragment() {
    vec4 base = texture(TEXTURE, UV);
    vec2 px = TEXTURE_PIXEL_SIZE;

    /* ---- outline 판정 ---- */
    bool empty = base.a <= ALPHA_THRES;
    bool within = false;

    // 컴파일 안전용 고정 루프 (최대 8)
    for (int dy = -8; dy <= 8; dy++) {
        for (int dx = -8; dx <= 8; dx++) {
            if (abs(dx) > outline_thickness || abs(dy) > outline_thickness) {
                continue;
            }
            if (dx == 0 && dy == 0) {
                continue;
            }

            float a = texture(TEXTURE, UV + vec2(float(dx), float(dy)) * px).a;
            if (a > ALPHA_THRES) {
                within = true;
            }
        }
    }

    bool outline = empty && within;

    /* ---- stripe 계산 (outline 영역용 마스크) ---- */
    float fill = 1.0;
    if (draw_mode == MODE_STRIPE_ONLY || draw_mode == MODE_STRIPE_WITH_TEXTURE) {
        float rotation = TIME * rotation_speed;

        // 텍스처 픽셀 기준 좌표 (중심 기준)
        vec2 p = vec2(
            floor((UV.x - 0.5) / px.x),
            floor((UV.y - 0.5) / px.y)
        );

        float angle = atan(
            p.x * cos(rotation) + p.y * sin(rotation),
            p.y * cos(rotation) - p.x * sin(rotation)
        );

        float t = mod((angle - PI) / -TAU, 1.0 / stripes);
        fill = t < stripe_width / stripes ? 1.0 : 0.0;
    }


	vec4 res_col = vec4(0.0);

	if (draw_mode == MODE_TEXTURE_ONLY) {
	    res_col = base;
	}
	else if (draw_mode == MODE_OUTLINE_ONLY) {
	    res_col = outline ? outline_color : vec4(0.0);
	}
	else if (draw_mode == MODE_OUTLINE_WITH_TEXTURE) {
	    res_col = outline ? outline_color : base;
	}
	else if (draw_mode == MODE_STRIPE_ONLY) {
	    res_col = (outline && fill > 0.0) ? outline_color : vec4(0.0);
	}
	else if (draw_mode == MODE_STRIPE_WITH_TEXTURE) {
	    res_col = (outline && fill > 0.0) ? outline_color : base;
	}

	COLOR = res_col;

}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_r4juh"]
resource_local_to_scene = true
shader = SubResource("Shader_s0ptb")
shader_parameter/draw_mode = 2
shader_parameter/outline_color = Color(1, 1, 1, 1)
shader_parameter/outline_thickness = 2
shader_parameter/rotation_speed = 0.3
shader_parameter/stripes = 16.0
shader_parameter/stripe_width = 0.5

[node name="PlayerTest" type="Node"]

[node name="Player" parent="." instance=ExtResource("1_kisq8")]
position = Vector2(392, 320)

[node name="Sprites" parent="Player" index="0"]
material = SubResource("ShaderMaterial_ip0k5")

[node name="HBoxContainer" parent="Player/PlayerStat" index="0"]
material = SubResource("ShaderMaterial_vaaja")

[node name="StaticBody2D" type="StaticBody2D" parent="."]
position = Vector2(396, 432)

[node name="CollisionShape2D" type="CollisionShape2D" parent="StaticBody2D"]
shape = SubResource("WorldBoundaryShape2D_s0ptb")

[node name="Enemy" parent="." instance=ExtResource("2_r4juh")]
material = SubResource("ShaderMaterial_r4juh")
position = Vector2(632, 152)

[editable path="Player"]
